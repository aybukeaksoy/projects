# -*- coding: utf-8 -*-
"""CENG403_Template_Public.ipynb adlı not defterinin kopyası

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/15D1iFo6hkU24hnmcp97jXbccEBrMxK9P

# CENG403 - Spring 2024 - THE1

In this take-home-exam, you will implement your own tensor library, called CerGen (short for CENG Gergen -- gergen: one of the Turkish translations of the term tensor).

Example usage:

```python
from cergen import rastgele_gercek,rastgele_dogal,cekirdek, gergen

boyut = (1,)
aralik = (0, 10)
g0 = rastgele_gercek(boyut, aralik)
print(g0)
1 boyutlu gergen:
8

g1 = gergen([[1, 2, 3], [4, 5, 6]])
print(g1)
2x3 boyutlu gergen:
[[1, 2, 3]
 [4, 5, 6]]

g2 = gergen(rastgele_dogal((3, 1)))
print(g2)
3x1 boyutlu gergen
[[6],
[5],
[2]]

print((g1 * g2))
2x1 boyutlu gergen:
[[22],
[61]]

g3 = (g1 * (g2 + 3)).topla()

```

## 1 Task Description
In this homework, we introduce the gergen class, a custom data structure designed to provide a
hands-on experience with fundamental array operations, mirroring some functionalities typically
found in libraries like NumPy.

## Fundamental Operations:
Random number generation:
"""

import random

def cekirdek(sayi: int):
    #Sets the seed for random number generation
    random.seed(sayi)

def rastgele_dogal(boyut, aralik=(0,100), dagilim='uniform'):
    """
    Generates data of specified dimensions with random integer values and returns a gergen object.

    Parameters:
    boyut (tuple): Shape of the desired data.
    aralik (tuple, optional): (min, max) specifying the range of random values. Defaults to (0,100), which implies a default range.
    dagilim (string, optional): Distribution of random values ('uniform'). Defaults to 'uniform'.

    Returns:
    gergen: A new gergen object with random integer values.
    """
    if dagilim=='uniform':
        return gergen(rastgele_helper(boyut,aralik,"dogal"))

    else:
        raise ValueError("Dagilim parameter has to be given as 'uniform'")

def rastgele_gercek(boyut, aralik=(0.0, 1.0), dagilim='uniform'):
    """
    Generates a gergen of specified dimensions with random floating-point values.

    Parameters:
    boyut (tuple): Shape of the desired gergen.
    aralik (tuple, optional): (min, max) specifying the range of random values. Defaults to (0.0, 1.0) for uniform distribution.
    dagilim (string, optional): Distribution of random value ('uniform'). Defaults to 'uniform'.

    Returns:
    gergen: A new gergen object with random floating-point values.
    """
    if dagilim=='uniform':
        return gergen(rastgele_helper(boyut,aralik,"gercek"))

    else:
        raise ValueError("Dagilim parameter has to be given as 'uniform'")

def rastgele_helper(boyut,aralik,func):

    if len(boyut)==0:
        if func=="dogal":
            data=random.randint(aralik[0], aralik[1])
        if func=="gercek":
            data=random.uniform(aralik[0], aralik[1])
        return data

    elif len(boyut)==1:
        data=[]
        for i in range(boyut[0]):
            if func=="dogal":
                data.append(random.randint(aralik[0], aralik[1]))
            if func=="gercek":
                data.append(random.uniform(aralik[0], aralik[1]))
        return data

    else:
        return [rastgele_helper(boyut[1:], aralik, func) for j in range(boyut[0])]

"""Operation class implementation:"""

class Operation:
    def __call__(self, *operands):
        """
        Makes an instance of the Operation class callable.
        Stores operands and initializes outputs to None.
        Invokes the forward pass of the operation with given operands.

        Parameters:
            *operands: Variable length operand list.

        Returns:
            The result of the forward pass of the operation.
        """
        self.operands = operands
        self.outputs = None
        return self.ileri(*operands)

    def ileri(self, *operands):
        """
        Defines the forward pass of the operation.
        Must be implemented by subclasses to perform the actual operation.

        Parameters:
            *operands: Variable length operand list.

        Raises:
            NotImplementedError: If not overridden in a subclass.
        """
        raise NotImplementedError

    def func_element_wise(self, data, shape, func=str,n=1):

        if len(shape) == 0:
            if func=="sin":
                return math.sin(data)
            if func=="cos":
                return math.cos(data)
            if func=="tan":
                return math.tan(data)
            if func=="us":
                if n<0:
                    raise ValueError("n should be a positive integer")
                return data**n
            if func=="log":
                return math.log(data,10)
            if func=="ln":
                return math.log(data)
            if func=="add":
                return data+n
            if func=="mul":
                return data*n
            if func=="div":
                if n==0:
                    raise ZeroDivisionError("Divison by zero cannot be performed")
                return data/n
            if func=="sub":
                return data-n

        else:
              return [self.func_element_wise(sub_veri, shape[1:], func,n) for sub_veri in data]

    def op_element_wise(self,self_data,other_data,shape,op):

        if len(shape)==0:
            if op=="mul":
                return self_data*other_data
            if op=="add":
                return self_data+other_data
            if op=="div":
                if other_data==0:
                    raise ZeroDivisionError("Divison by zero cannot be performed")
                return self_data/other_data
            if op=="sub":
                return self_data-other_data

        else:
            return [self.op_element_wise(self_sub_veri, other_sub_veri, shape[1:], op) for self_sub_veri, other_sub_veri in zip(self_data,other_data)]

    def find_shape(self, veri, shape):

        if type(veri)==int or type(veri)==float:
            return shape
        else:
            shape.append(len(veri))
            return self.find_shape(veri[0],shape)

    def zeros(self,shape):
      if len(shape)==0:
          return 0
      if len(shape) == 1:
          return [0] * shape[0]
      else:
          return [self.zeros(shape[1:]) for _ in range(shape[0])]



import math
from typing import Union

class gergen:

    __veri = None #A nested list of numbers representing the data
    D = None # Transpose of data
    __boyut = None #Dimensions of the derivative (Shape)


    def __init__(self, veri=None):
    # The constructor for the 'gergen' class.
    #
    # This method initializes a new instance of a gergen object. The gergen can be
    # initialized with data if provided; otherwise, it defaults to None, representing
    # an empty tensor.
    #
    # Parameters:
    # veri (int/float, list, list of lists, optional): A nested list of numbers that represents the
    # gergen data. The outer list contains rows, and each inner list contains the
    # elements of each row. If 'veri' is None, the tensor is initialized without data.
    #
    # Example:
    # To create a tensor with data, pass a nested list:
    # tensor = gergen([[1, 2, 3], [4, 5, 6]])
    #
    # To create an empty tensor, simply instantiate the class without arguments:
    # empty_tensor = gergen()

        if veri!=None:
            self.__veri=veri
            self.__boyut=tuple(self.find_shape(veri,[]))
            self.D=Shape.transpose_class(self.__veri,self.__boyut)


    def __getitem__(self, index):
    #Indexing for gergen objects
        data=self.listeye()
        shape=self.boyut()
        if (not len(shape)) or (type(index)==int and index>=shape[0]):
            raise IndexError("index out of bounds")
        else:
            return self.get_helper(data,index)

    def get_helper(self,data,index):
        if isinstance(index, int) or isinstance(index,slice):
            return gergen(data[index])
        else:
            return gergen(self.get_helper(data[index[0]],index[1:]))

    def __str__(self):
        #Generates a string representation
        if self.listeye()==None:
            return "Empty Gergen"
        else:
            shape_str=""
            for b in self.boyut():
                shape_str+=str(b)+"x"
            if shape_str=="":
                shape_str+="0x"
            return shape_str[:-1]+ " boyutlu gergen:"+ "\n" + self.str_helper(self.listeye(),len(self.boyut()))

    def str_helper(self,data, shape,depth=0):
        if not shape:
            return str(data)
        elif not isinstance(data[0], list):
            return str(data)
        else:
            inner_results = []
            for subdata in data:
                inner_results.append(self.str_helper(subdata, shape, depth + 1))

            result = "[" +("\n"*(shape-depth-1)).join(r for r in inner_results) + "]"
            return result

    def __mul__(self, other: Union['gergen', int, float]) -> 'gergen':
        """
        Multiplication operation for gergen objects.
        Called when a gergen object is multiplied by another, using the '*' operator.
        Could be element-wise multiplication or scalar multiplication, depending on the context.
        """
        multiplication_operation = FourOperations()
        return multiplication_operation(self, other,"mul")

    def __rmul__(self, other):
        multiplication_operation = FourOperations()
        return multiplication_operation(self,other,"mul")


    def __truediv__(self, other: Union['gergen', int, float]) -> 'gergen':
        """
        Division operation for gergen objects.
        Called when a gergen object is divided by another, using the '/' operator.
        The operation is element-wise.
        """

        division_operation = FourOperations()
        return division_operation(self, other,"div")


    def __add__(self, other: Union['gergen', int, float]) -> 'gergen':
        """
        Defines the addition operation for gergen objects.
        Called when a gergen object is added to another, using the '+' operator.
        The operation is element-wise.
        """

        addition_operation = FourOperations()
        return addition_operation(self, other,"add")

    def __radd__(self,other):

        addition_operation = FourOperations()
        return addition_operation(self, other,"add")


    def __sub__(self, other: Union['gergen', int, float]) -> 'gergen':
        """
        Subtraction operation for gergen objects.
        Called when a gergen object is subtracted from another, using the '-' operator.
        The operation is element-wise.
        """

        substraction_operation = FourOperations()
        return substraction_operation(self, other,"sub")

    def __rsub__(self,other):

        addition_operation = FourOperations()
        return addition_operation(self*(-1), other,"add")

    def boyut(self):
    # Returns the shape of the gergen
        return self.__boyut

    def find_shape(self, veri, shape):
        if type(veri)==int or type(veri)==float:
            return shape
        else:
            shape.append(len(veri))
            return self.find_shape(veri[0],shape)

    def uzunluk(self):
    # Returns the total number of elements in the gergen
        length=1
        for b in self.boyut():
            length*=b
        return length


    def devrik(self):
    # Returns the transpose of gergen
        return self.D


    def sin(self):
    #Calculates the sine of each element in the given `gergen`.
        sin_function = Function()
        return sin_function(self,"sin")

    def cos(self):
    #Calculates the cosine of each element in the given `gergen`.
        cos_function = Function()
        return cos_function(self,"cos")

    def tan(self):
    #Calculates the tangent of each element in the given `gergen`.
        tan_function = Function()
        return tan_function(self,"tan")

    def us(self, n: int):
    #Raises each element of the gergen object to the power 'n'. This is an element-wise operation.
        us_function = Function()
        return us_function(self,"us",n)

    def log(self):
    #Applies the logarithm function to each element of the gergen object, using the base 10.
        log_function = Function()
        return log_function(self,"log")

    def ln(self):
    #Applies the natural logarithm function to each element of the gergen object.
        ln_function = Function()
        return ln_function(self,"ln")

    def L1(self):
    # Calculates and returns the L1 norm
        norm_1 = Norm()
        return norm_1(self,1)


    def L2(self):
    # Calculates and returns the L2 norm
        norm_2 = Norm()
        return norm_2(self,2)

    def Lp(self, p):
    # Calculates and returns the Lp norm, where p should be positive integer
        if p<=0:
            raise ValueError("p should be a positive integer")
        norm_p = Norm()
        return norm_p(self,p)


    def listeye(self):
    #Converts the gergen object into a list or a nested list, depending on its dimensions.
        return self.__veri

    def duzlestir(self):
    #Converts the gergen object's multi-dimensional structure into a 1D structure, effectively 'flattening' the object.
        flatten_operation = Shape()
        return flatten_operation(self, "duzlestir")


    def boyutlandir(self, yeni_boyut):
    #Reshapes the gergen object to a new shape 'yeni_boyut', which is specified as a tuple.
        if type(yeni_boyut)!=tuple:
            raise TypeError("yeni_boyut must be a tuple")
        reshape_operation = Shape()
        return reshape_operation(self, "boyutlandir",yeni_boyut)


    def ic_carpim(self, other):
    #Calculates the inner (dot) product of this gergen object with another.
        inner_product = Product()
        return inner_product(self, other, "ic_carpim")


    def dis_carpim(self, other):
    #Calculates the outer product of this gergen object with another.
        outer_product = Product()
        return outer_product(self, other, "dis_carpim")

    def topla(self, eksen=None):
    #Sums up the elements of the gergen object, optionally along a specified axis 'eksen'.

        sum_operation= Sum()
        return sum_operation(self,eksen, "topla")


    def ortalama(self, eksen=None):
    #Calculates the average of the elements of the gergen object, optionally along a specified axis 'eksen'.

        avg_operation= Sum()
        return avg_operation(self, eksen, "ortalama")

class FourOperations(Operation):

    def ileri(self, self_gergen, other: Union['gergen', int, float], func:str):

        self_data=self_gergen.listeye()
        self_shape=self_gergen.boyut()

        if not isinstance(other, (int,float,gergen)):
            raise TypeError("Other parameter must be an int, float or a gergen object")
        elif isinstance(other, (int, float)):
            return gergen(self.func_element_wise(self_data,self_shape,func,other))
        else:
            other_data=other.listeye()
            other_shape=other.boyut()
            if self_shape!=other_shape and len(other_shape) and len(self_shape):
                raise ValueError("Dimensions do not align for element-wise operation")
            elif not len(other_shape):
                return gergen(self.func_element_wise(self_data,self_shape,func,other_data))
            elif not len(self_shape):
                return gergen(self.func_element_wise(other_data,other_shape,func,self_data))
            else:
                return gergen(self.op_element_wise(self_data,other_data,self_shape,func))

class Function(Operation):

    def ileri(self,self_gergen,func,n=1):
        shape=self_gergen.boyut()
        data=self_gergen.listeye()
        return gergen(self.func_element_wise(data, shape, func,n))

class Norm(Operation):

    def ileri(self,self_gergen,p) -> float:
        shape=self_gergen.boyut()
        data=self_gergen.listeye()
        L=self.find_norm(data,shape,p)
        L=L**(1/p)
        return L

    def find_norm(self, data, shape, p):
        if len(shape) == 0:
            return float(data)
        elif len(shape) == 1:
            return sum([abs(v)**p for v in data])
        else:
            return sum([self.find_norm(sub_veri, shape[1:],p) for sub_veri in data])

class Shape(Operation):

    def ileri(self,self_gergen, func:str, new_shape=()):

        shape=self_gergen.boyut()
        data=self_gergen.listeye()

        if func=="devrik":
            return gergen(self.transpose(data,shape))

        if func=="duzlestir":
            return gergen(self.flatten(data))

        if func=="boyutlandir":
            return gergen(self.reshape(shape,data,new_shape))

    def find_length(self,shape):
        length=1
        for b in shape:
            length*=b
        return length

    def flatten(self,data):
        if data==[]:
            return []
        elif type(data)==int or type(data)==float:
            return data
        elif type(data[0])==list:
            return self.flatten(data[0])+self.flatten(data[1:])
        else:
            return [data[0]]+self.flatten(data[1:])

    @classmethod
    def flatten_class(cls, data):
        return cls().flatten(data)

    def reshape_recursive(self, data, new_shape):
        if len(new_shape) == 1:
            return data
        outer_size = new_shape[0]
        size = len(data) // outer_size
        return [self.reshape_recursive(data[i * size:(i + 1) * size], new_shape[1:]) for i in range(outer_size)]

    def generate_combinations(self,list_of_ranges, current_combination=[]):
      if not list_of_ranges:
          return [current_combination]
      combinations = []
      for i in range(list_of_ranges[0]):
          combinations.extend(self.generate_combinations(list_of_ranges[1:], current_combination + [i]))
      return combinations

    def find_coeff_list(self,shape):
      coeff_list1=[1]
      coeff_list2=[1]
      for i in range(len(shape)-1):
          coeff_list1.append(coeff_list1[i]*shape[::-1][i])
          coeff_list2.append(coeff_list2[i]*shape[i])
      return coeff_list1[::-1], coeff_list2[::-1]

    def transpose(self,data,shape):
    # Returns the transpose of gergen
        if len(shape)==0:
            return data
        list_of_ranges=[]
        coeff_list1, coeff_list2=self.find_coeff_list(list(shape))
        list1=self.flatten(data)
        list2=[0] * len(list1)

        for i in shape:
            list_of_ranges.append(i)
        combinations=self.generate_combinations(list_of_ranges)

        for combination in combinations:
            index1=sum([x * y for x, y in zip(combination, coeff_list1)])
            index2=sum([x * y for x, y in zip(combination[::-1], coeff_list2)])
            list2[index2]=list1[index1]

        return self.reshape_recursive(list2,list(shape)[::-1])

    @classmethod
    def transpose_class(cls, data, shape):
        return cls().transpose(data, shape)


    def reshape(self, shape, data, new_shape):
    #Reshapes the gergen object to a new shape 'yeni_boyut', which is specified as a tuple.
        if len(shape)==0:
            return data
        self_num_of_elem=self.find_length(shape)
        flattened_data= self.flatten(data)
        other_num_of_elem=1
        for b in new_shape:
            other_num_of_elem*=b
        if self_num_of_elem != other_num_of_elem:
            raise ValueError("yeni_boyut does not match the total number of elements in the original tensor")
        else:
            reshaped_data = self.reshape_recursive(flattened_data, new_shape)
            return reshaped_data

class Product(Operation):

    def ileri(self,self_gergen,other, func=str):

        if func=="ic_carpim":
            if not isinstance(self_gergen, gergen) or not isinstance(other, gergen):
                raise TypeError("Types do not align")
            return gergen(self.inner_product(self_gergen, other))
        if func=="dis_carpim":
            if not isinstance(self_gergen, gergen) or not isinstance(other, gergen):
                raise TypeError("Types do not align")
            return gergen(self.outer_product(self_gergen, other))


    def inner_product(self, self_gergen, other):
        self_shape=self_gergen.boyut()
        other_shape=other.boyut()
        self_veri=self_gergen.listeye()
        other_veri=other.listeye()

        if len(self_shape)==1 and len(other_shape)==1 and self_shape!=other_shape:
            raise ValueError("The Lengths of 1-D vectors do not match")
        elif len(self_shape)==1 and len(other_shape)==1 and self_shape==other_shape:
            return sum([x*y for x,y in zip(self_veri,other_veri)])
        elif self_shape[1]!=other_shape[0]:
            raise ValueError("The Dimensions of 2-D vectors do not match")
        else:
            result=self.zeros((self_shape[0],other_shape[1]))
            for i in range(self_shape[0]):
                for j in range(other_shape[1]):
                    for k in range(other_shape[0]):
                        result[i][j] += self_veri[i][k] * other_veri[k][j]
            return result


    def outer_product(self, self_gergen, other):
    #Calculates the outer product of this gergen object with another.
        self_shape=self_gergen.boyut()
        other_shape=other.boyut()
        if len(self_shape)!=1 or len(other_shape)!=1:
            raise ValueError("Both operands must be 1-D arrays")
        else:
            self_veri=self_gergen.listeye()
            other_veri=other.listeye()
            result=[]
            for i in range(self_shape[0]):
                row=[]
                for j in range(other_shape[0]):
                    row.append(self_veri[i]*other_veri[j])
                result.append(row)
            return result

class Sum(Operation):

    def ileri(self,self_gergen,axis, func=str):

      shape=self_gergen.boyut()
      data=self_gergen.listeye()
      count=axis
      if axis!=None and type(axis)!=int:
          raise TypeError("Eksen must be an integer or None")
      if type(axis)==int and axis>=len(shape):
          raise ValueError("Eksen is out of bounds")
      if func=="topla":
          if axis==None and len(shape):
              return float(sum(Shape.flatten_class(data)))
          elif axis==None:
              return float(data)
          return gergen(self.sum_helper(data,shape,axis,count))
      if func=="ortalama":
          if axis==None and len(shape):
              return float(sum(Shape.flatten_class(data)))/self_gergen.uzunluk()
          elif axis==None:
              return float(data)
          new_data=self.sum_helper(data,shape,axis,count)
          new_shape=self.find_shape(new_data,[])
          return gergen(self.func_element_wise(new_data,new_shape,"div", shape[axis]))

    def sum_helper(self,data,shape,axis,count):
        if(count==0):
            new_shape=self.find_shape(data[0],[])
            result=self.zeros(new_shape)
            for i in range(shape[axis]):
                if type(result)==int:
                    result+=data[i]
                else:
                    result=self.op_element_wise(result,data[i],new_shape,"add")
            return result
        else:
            return [self.sum_helper(subdata,shape,axis,count-1) for subdata in data]



"""## 2 Compare with NumPy"""

import numpy as np              # NumPy, for working with arrays/tensors
import time                     # For measuring time

"""**Example 1:**
Using rastgele_gercek(), generate two gergen objects with shapes (64,64) and calculate the a.ic carpim(b). Then, calculate the same function with NumPy and report the time and difference.
"""

def example_1():
    #Example 1
    boyut = (64,64)
    g1 = rastgele_gercek(boyut)
    g2 = rastgele_gercek(boyut)

    start = time.time()
    #TODO
    #Apply given equation
    result=g1.ic_carpim(g2)
    end = time.time()

    start_np = time.time()
    result_np=np.dot(g1.listeye(),g2.listeye())
    #Apply the same equation for NumPy equivalent
    end_np = time.time()

    difference=np.sum(result.listeye()-result_np)

    #TODO:
    #Compare if the two results are the same
    #Report the time difference

    #print("Result for gergen:\n", result)
    #print("Result for numpy:\n", result_np)
    print("Difference between the results:",difference)

    print("Time taken for gergen:", end-start)
    print("Time taken for numpy:", end_np-start_np)



#example_1()

"""**Example 2:**
Using rastgele_gercek(), generate three gergen’s a, b and c with shapes (4,16,16,16). Calculate given equation:

> (a×b + a×c + b×c).ortalama()

Report the time and whether there exists any computational difference in result with their NumPy equivalent.
"""

def example_2():
    #Example 2
    #TODO:
    boyut=(4,16,16,16)

    a=rastgele_gercek(boyut)
    b=rastgele_gercek(boyut)
    c=rastgele_gercek(boyut)

    a_veri=np.array(a.listeye())
    b_veri=np.array(b.listeye())
    c_veri=np.array(c.listeye())

    start = time.time()
    result=(a*b+a*c+b*c).ortalama()
    end = time.time()

    start_np = time.time()
    result_np=(a_veri*b_veri+a_veri*c_veri+b_veri*c_veri).mean()
    end_np = time.time()

    difference=result-result_np

    print("Result for gergen:\n", result)
    print("Result for numpy:\n", result_np)
    print("Difference between the results:",difference)

    print("Time taken for gergen:", end-start)
    print("Time taken for numpy:", end_np-start_np)

#example_2()

"""**Example 3**: Using rastgele_gercek(), generate three gergen’s a and b with shapes (3,64,64). Calculate given equation:


> $\frac{\left(\ln\left(\sin(a) + \cos(b)\right)\right)^2}{8}$


Report the time and whether there exists any computational difference in result with their NumPy equivalent.

"""

def example_3():
    #Example 3
    #TODO:
    boyut=(3,64,64)

    a=rastgele_gercek(boyut)
    b=rastgele_gercek(boyut)

    a_veri=np.array(a.listeye())
    b_veri=np.array(b.listeye())

    result=(((a.sin()+b.cos()).us(2)).ln())/8
    result_np= np.log((np.sin(a_veri) + np.cos(b_veri))**2) / 8

    start = time.time()
    result=(((a.sin()+b.cos()).us(2)).ln())/8
    end = time.time()

    start_np = time.time()
    result_np=np.log((np.sin(a_veri) + np.cos(b_veri))**2) / 8
    end_np = time.time()

    difference=np.sum(result.listeye()-result_np)

    #print("Result for gergen:\n", result)
    #print("Result for numpy:\n", result_np)
    print("Difference between the results:",difference)

    print("Time taken for gergen:", end-start)
    print("Time taken for numpy:", end_np-start_np)


#example_3()

"""
TIME AND RESULT COMPARISON

In this part, comparing our implementation and the numpy equivalent, we have observed the differences in time and results. The values are as:

For example 1: 

Difference between the results: -1.1191048088221578e-13
Time taken for gergen: 0.0575098991394043
Time taken for numpy: 0.0014982223510742188

For example 2:

Result for gergen:
 0.7497753019159114
Result for numpy:
 0.7497753019159132
Difference between the results: -1.887379141862766e-15
Time taken for gergen: 0.26454973220825195
Time taken for numpy: 0.00020503997802734375

For example 3:

Difference between the results: -2.717010644248674e-16
Time taken for gergen: 0.2249758243560791
Time taken for numpy: 0.00032329559326171875

As it can be seen, there is a small difference in the outputs of our implementation and numpy equivalent.
Since we are operating with floating point numbers in those cases, the real number cannot be represented exactly. 
This will lead to rounding errors or accumulating errors occurring during recursion or iteration. 
Due to this limited precision, also the comparison cannot be done perfectly. As the input size grows,
this error and difference might grow leading to unstability. 

Also, looking at the time taken for the operations with our implementation and numpy equivalent, we can observe that numpy is 
significantly faster in all cases. I have used recursion for most of the functions and it might be more time consuming 
than the iterative approaches. Even if the logic and algorithm for most operations might be the same with numpy, 
numpy is faster as it is implemented in C and extremely optimized. Numpy also utilizes multithreading etc for complex operations. 
Hence, numpy equivalents are very efficient and this time difference will grow as the input sizes grow.

"""